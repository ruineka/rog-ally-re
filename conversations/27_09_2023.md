I'm looking at the ACPI of the Ally again and some things are speaking to me. Under the PNP0C14 entry for WMI I see this.

```
                Name (GPST, Package (0x02)
                {
                    0x50, 
                    0x48
                })
                Method (DGPS, 2, NotSerialized)
                {
                    If ((Arg0 >= SizeOf (Arg1)))
                    {
                        Return (Zero)
                    }

                    ^^PCI0.GPP0.PEGP.NLIM = One
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
                    Notify (^^PCI0.GPP0.PEGP, 0xC0) // Hardware-Specific
                    Return (One)
                }
```

GPST (Gamepad State)

DGPS (Digital/Dynamic Gamead State)

This is all under the ATKD Scope which is directly related to the keyboard IIRC.

```
            Scope (\_SB.ATKD)
            {
                Method (WLED, 1, NotSerialized)
                {
                    SGOV (One, One, Arg0)
                    Arg0 ^= One
                    If (((WAPF && 0x05) == Zero)){}
                    Return (One)
                }

                Method (BLED, 1, NotSerialized)
                {
                    SGOV (One, One, Arg0)
                    Return (One)
                }

                Name (WAPF, Zero)
                Method (CWAP, 1, NotSerialized)
                {
                    WAPF |= Arg0 /* \_SB_.ATKD.WAPF */
                    Return (One)
                }

                Name (GPST, Package (0x02)
                {
                    0x50, 
                    0x48
                })
                Method (DGPS, 2, NotSerialized)
                {
                    If ((Arg0 >= SizeOf (Arg1)))
                    {
                        Return (Zero)
                    }

                    ^^PCI0.GPP0.PEGP.NLIM = One
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
                    Notify (^^PCI0.GPP0.PEGP, 0xC0) // Hardware-Specific
                    Return (One)
                }
            }
```

Full scope
WLED (Wireless LED)
BLED (Bluetooth LED)
WAPF (???)
GPST (Gamepad State)
DGPST (Dynamic Gamepad State)
 - WAPF defines the behavior of the Fn+Fx wlan key
 - The significance of values is yet to be found, but
 - most of the time:
 - Bit | Bluetooth | WLAN
    - 0  | Hardware  | Hardware
    - 1  | Hardware  | Software
    - 4  | Software  | Software

ssdt8:

```
Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
            {
                _PSC = Zero
                If ((DGPS != Zero))
                {
                    \_SB.PCI0.GPP0.M237._ON ()
                    DGPS = Zero
                }
            }

            Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
            {
                If ((OPCE == 0x03))
                {
                    If ((DGPS == Zero))
                    {
                        \_SB.PCI0.GPP0.M237._OFF ()
                        DGPS = One
                    }

                    OPCE = 0x02
                }

                _PSC = 0x03
            }
```

On/Off switch for the DGPS
Looks like _SB.PCI0.GPP0.M237._ON and _SB.PCI0.GPP0.M237._OFF are our calls we want.

```
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
```
I guess it would make sense to disable the gamepad so that games don't have controller 1/controller 2 issues.
```
[ruineka@ruineka-devonenotebookpc acpidump]$ grep -i "TGPU" *.dsl
dsdt.dsl:    External (_SB_.PCI0.GPP0.PEGP.TGPU, UnknownObj)
dsdt.dsl:                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
dsdt.dsl:            ^^^GPP0.PEGP.TGPU = Local0
ssdt8.dsl:            CreateDWordField (GPSP, 0x08, TGPU)
ssdt8.dsl:                                TGPU = Zero
ssdt8.dsl:                                If ((TGPU == Zero))
ssdt8.dsl:                                    TGPU = \_SB.PCI0.SBRG.EC0.STCC (Zero, 0x27)
```

```
                Name (_S0W, 0x04)  // _S0W: S0 Device Wake State
                Method (_RMV, 0, NotSerialized)  // _RMV: Removal Status
                {
                    Return (Zero)
                }

                Name (DDPM, Package (0x02)
                {
                    0x08, 
                    0x04
                })
                Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
                {
                    Return (DDPM) /* \_SB_.PCI0.GPP0.SWUS.SWDS.DDPM */
                }
```
SSDT8 has all of our sleep stuff.

It definitely looks like VGA (XG mobile) is directly linked to our gamepad stuff.
```
                Device (VGA)
                {
                    Name (_ADR, Zero)  // _ADR: Address
                    Method (_RMV, 0, NotSerialized)  // _RMV: Removal Status
                    {
                        Return (Zero)
                    }

                    Method (_EJ0, 1, NotSerialized)  // _EJx: Eject Device, x=0-9
                    {
                        M460 ("Jacky- GC32L _EJ0 entry \n", Zero, Zero, Zero, Zero, Zero, One)
                        If ((GPCE == One))
                        {
                            M460 ("Jacky- GC32L _EJ0 1 \n", Zero, Zero, Zero, Zero, Zero, One)
                            SGPC (Zero)
                            \_SB.PCI0.GPP0.M237.M239 = Zero
                            WOSR = Zero
                            M460 ("Jacky- GC32L _EJ0 2 \n", Zero, Zero, Zero, Zero, Zero, One)
                        }

                        M460 ("Jacky- GC32L _EJ0 exit \n", Zero, Zero, Zero, Zero, Zero, One)
                    }
                }
```

I bet if someone has an XG mobile and has it enabled when booting into linux their keyboard won't disappear.
I think the fix for XG mobile on Windows broke the keyboard for us.

At least it led me down the path to sleep/wake stuff. I really want to know if XG mobile changes our sleep behaviors though.

In SSDT8
```
                          If ((\_SB.ATKD.MMFG == One))
                            {
                                \_SB.ATKD.MMFG = Zero
                            }
```

Thats all under NPCF (Nvidia Platform Controller Framework?)

__GOOD OBSERVATION!__ in an amd device, nvidia still finds a way to fuck us, if that's what NPCF stands for

SSDT8 seems to be directly related to GPU/XG mobile stuff though and the sleep slates for it.

__WASTED HOPES__ How nice would it be if the October 12th BIOS update just fixes sleep for us with no extra effort? Lmao

RHUB = Root Hub?
```
Scope (\_SB.PCI0.GP19.XHC3.RHUB.PRT2)
```

XHCI Root Hub Port 2?

```
ruineka@ruineka-devonenotebookpc acpidump]$ grep -i "RHUB" *.dsl
NeroReflex
_neroreflex_
Online

NeroReflex â€” Ieri alle 03:43
My current theory, looking at windows is that two of those commands are needed, probably to tell the controller "no, do not expect to enter BIOS"
I fear that, even after being able to wake the controller properly we will never know the reason behind it
Asus won't tell us
tomoniutaou33 â€” Ieri alle 03:52
If only ACSE could be made compatible with linux.
pastaq â€” Ieri alle 03:58
Oh please no
Just give us the data to do it right
tomoniutaou33 â€” Ieri alle 04:07
data??
tomoniutaou33 â€” Ieri alle 04:20
Also, if you can set it as a steam button instead of an xbox button, I think you can use it as a mouse or click even in desktop mode.  If you can use the controller with handyGccs or OGUI without any problems, I think it will be even easier to use if you reverse it.
TwinHaelix â€” Ieri alle 05:23
@pastaq One theory I've been considering is that we should just emulate a steam controller at the HIDRAW level so that SDL and others pick it up natively.  I just ran across https://docs.kernel.org/hid/uhid.html and it looks like it might be just what we need to do that?
With UHID, a user-space transport driver can create kernel hid-devices for each device connected to the user-space controlled bus. The UHID API defines the I/O events provided from the kernel to user-space and vice versa.
the example in the linux source includes defining a report descriptor... if I'm not mistaken, could that mean we could just fake the report descriptor of the steam controller?
Immagine
TwinHaelix â€” Ieri alle 05:38
Don't know if it's using UHID or just HID, but this project looks to be a great reference: https://github.com/kozec/sc-controller
GitHub
GitHub - kozec/sc-controller: User-mode driver and GTK3 based GUI f...
User-mode driver and GTK3 based GUI for Steam Controller - GitHub - kozec/sc-controller: User-mode driver and GTK3 based GUI for Steam Controller
GitHub - kozec/sc-controller: User-mode driver and GTK3 based GUI f...
tomoniutaou33 â€” Ieri alle 05:53
MCU ACSE bios update has arrived!  !  I'll try it!  !
Enhancement: Microcontroller Unit firmware can now be updated through the Armoury Crate SE Update Center
pastaq â€” Ieri alle 06:20
Interesting
pastaq â€” Ieri alle 06:23
How does this compare to eBPF? I think that capability allows us to steal existing hid's and combine them to make a virtual device. If we can avoid reimplementing basic functionality and just focus on translation that would be ideal for rapid development.
I suppose we need to look at if eBPF and SDL jive?
ashtophet101 â€” Ieri alle 08:12
FYI, the new MCU firmware update does not change the N-KEY behavior when sleeping ðŸ˜¦
tomoniutaou33 â€” Ieri alle 08:35
Will the trigger now function properly?
SightlyJester â€” Ieri alle 09:03
It's the new update also fixed deadzone joysticks to Linux? HoloISO and ChimeraOS?
adolfotregosa â€” Ieri alle 09:04
What about bios 330?
Still to be released? Oh..
ashtophet101 â€” Ieri alle 09:07
the trigger issue was resolved in a previous update, with this one AC includes a callibration tool
tomoniutaou33 â€” Ieri alle 09:22
bios330 is October 12th!
philmmanjaro â€” Ieri alle 12:06
Seems the ALLY has several firmwares which most likely get updated via Windows somehow. Some you can update from UEFI via USB-Stick and power cord connected.
MCU seems to be harder to been updated without Windows.
also do we know a way to figure out which exact versions of all the firmwares are given on a device? Only via the Windows tools from ASUS?
TwinHaelix â€” Ieri alle 12:40
Tbh I'm having a hard time understanding the capabilities of eBPF. It's clear that it can filter packets and insert/modify them, but I can't find any documentation I can understand about creating a new virtual device and combining/redirecting packets to it. It could simply be a limitation of my understanding.
SDL has merged the feature to link evdevs by their uniq attr, which is way easier than recombining data into a single device, but it's targeting SDL 3.0. Slouken says the feature is a good candidate for backporting to SDL 2 but I'm not sure I'm up to the task of creating a PR for that myself (SDL is a complicated beast)
Without the evdev linking, SDL 2.0 currently only works with steam controllers, dualshock, etc. through hidraw.
tomoniutaou33 â€” Ieri alle 13:02
The joystick and trigger calibration on the MCU313 is amazing.
B or C in handyGccs.  Can I change the start.select and AC.CC buttons by remapping the controller from controller settings?
I think it's assigned to the xbox button and xbox+A, but is it possible to change both?
tomoniutaou33 â€” Ieri alle 14:14
I updated it.  As a test, I reinstalled handyGccs and remapped it as if there was nothing.  CC button select.I finished without inputting anything to AC button, but AC button now requires long press of select.  And all the controllers were buggy after waking up from sleep.
WagesOf â€” Ieri alle 14:33
Is this done in armoury crate or is there some new interface to do things in mcu?
jlobue10 â€” Ieri alle 14:42
I think the calibration is done in ACSE (from reading about the update) 
I didn't install that update yet though
WagesOf â€” Ieri alle 14:52
bleah, well I guess it's time to go back into the swamp. ðŸ˜„
NeroReflex â€” Ieri alle 15:17
Actual fix for the suspend: write the mcu firmware 305 at linux boot andÃ² rewriting the dump at poweroff lol
jlobue10 â€” Ieri alle 15:27
Seems a bit long and excessive ðŸ˜‚ 
I'm sure we'll crack it with enough time and effort
WagesOf â€” Ieri alle 15:35
Tipo di allegato: archive
MCU313.zip
1.65 MB
Ruineka â€” Ieri alle 15:36
I'm looking at the ACPI of the Ally again and some things are speaking to me. Under the PNP0C14 entry for WMI I see this.

                Name (GPST, Package (0x02)
                {
                    0x50, 
                    0x48
                })
                Method (DGPS, 2, NotSerialized)
                {
                    If ((Arg0 >= SizeOf (Arg1)))
                    {
                        Return (Zero)
                    }

                    ^^PCI0.GPP0.PEGP.NLIM = One
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
                    Notify (^^PCI0.GPP0.PEGP, 0xC0) // Hardware-Specific
                    Return (One)
                }

GPST (Gamepad State)

DGPS (Digital/Dynamic Gamead State)

This is all under the ATKD Scope which is directly related to the keyboard IIRC.
            Scope (\_SB.ATKD)
            {
                Method (WLED, 1, NotSerialized)
                {
                    SGOV (One, One, Arg0)
                    Arg0 ^= One
                    If (((WAPF && 0x05) == Zero)){}
                    Return (One)
                }

                Method (BLED, 1, NotSerialized)
                {
                    SGOV (One, One, Arg0)
                    Return (One)
                }

                Name (WAPF, Zero)
                Method (CWAP, 1, NotSerialized)
                {
                    WAPF |= Arg0 /* \_SB_.ATKD.WAPF */
                    Return (One)
                }

                Name (GPST, Package (0x02)
                {
                    0x50, 
                    0x48
                })
                Method (DGPS, 2, NotSerialized)
                {
                    If ((Arg0 >= SizeOf (Arg1)))
                    {
                        Return (Zero)
                    }

                    ^^PCI0.GPP0.PEGP.NLIM = One
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
                    Notify (^^PCI0.GPP0.PEGP, 0xC0) // Hardware-Specific
                    Return (One)
                }
            }

Full scope
WLED (Wireless LED)
BLED (Bluetooth LED)
WAPF (???)
GPST (Gamepad State)
DGPST (Dynamic Gamepad State)
WAPF defines the behavior of the Fn+Fx wlan key
The significance of values is yet to be found, but
most of the time:
Bit | Bluetooth | WLAN
0  | Hardware  | Hardware
1  | Hardware  | Software
4  | Software  | Software
WagesOf â€” Ieri alle 15:43
Wow, yeah that calibration tool is exactly what I needed.
Ruineka â€” Ieri alle 15:45
ssdt8
            Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
            {
                _PSC = Zero
                If ((DGPS != Zero))
                {
                    \_SB.PCI0.GPP0.M237._ON ()
                    DGPS = Zero
                }
            }

            Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
            {
                If ((OPCE == 0x03))
                {
                    If ((DGPS == Zero))
                    {
                        \_SB.PCI0.GPP0.M237._OFF ()
                        DGPS = One
                    }

                    OPCE = 0x02
                }

                _PSC = 0x03
            }
On/Off switch for the DGPS
Looks like _SB.PCI0.GPP0.M237._ON and _SB.PCI0.GPP0.M237._OFF are our calls we want.
WagesOf â€” Ieri alle 15:49
Still no functionality to remap ac or cc buttons in the new ac/mcu firmware.
Ruineka â€” Ieri alle 15:49
Does the ally changes gamepad modes when it's hooked up to the XG mobile?
WagesOf â€” Ieri alle 15:49
So insistent that we use the asus crapware.
Ruineka â€” Ieri alle 15:49
                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
I guess it would make sense to disable the gamepad so that games don't have controller 1/controller 2 issues.
[ruineka@ruineka-devonenotebookpc acpidump]$ grep -i "TGPU" *.dsl
dsdt.dsl:    External (_SB_.PCI0.GPP0.PEGP.TGPU, UnknownObj)
dsdt.dsl:                    ^^PCI0.GPP0.PEGP.TGPU = DerefOf (Arg1 [Arg0])
dsdt.dsl:            ^^^GPP0.PEGP.TGPU = Local0
ssdt8.dsl:            CreateDWordField (GPSP, 0x08, TGPU)
ssdt8.dsl:                                TGPU = Zero
ssdt8.dsl:                                If ((TGPU == Zero))
ssdt8.dsl:                                    TGPU = \_SB.PCI0.SBRG.EC0.STCC (Zero, 0x27)
                Name (_S0W, 0x04)  // _S0W: S0 Device Wake State
                Method (_RMV, 0, NotSerialized)  // _RMV: Removal Status
                {
                    Return (Zero)
                }

                Name (DDPM, Package (0x02)
                {
                    0x08, 
                    0x04
                })
                Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
                {
                    Return (DDPM) /* \_SB_.PCI0.GPP0.SWUS.SWDS.DDPM */
                }
SSDT8 has all of our sleep stuff.
Ruineka â€” Ieri alle 16:00
It definitely looks like VGA (XG mobile) is directly linked to our gamepad stuff.
                Device (VGA)
                {
                    Name (_ADR, Zero)  // _ADR: Address
                    Method (_RMV, 0, NotSerialized)  // _RMV: Removal Status
                    {
                        Return (Zero)
                    }

                    Method (_EJ0, 1, NotSerialized)  // _EJx: Eject Device, x=0-9
                    {
                        M460 ("Jacky- GC32L _EJ0 entry \n", Zero, Zero, Zero, Zero, Zero, One)
                        If ((GPCE == One))
                        {
                            M460 ("Jacky- GC32L _EJ0 1 \n", Zero, Zero, Zero, Zero, Zero, One)
                            SGPC (Zero)
                            \_SB.PCI0.GPP0.M237.M239 = Zero
                            WOSR = Zero
                            M460 ("Jacky- GC32L _EJ0 2 \n", Zero, Zero, Zero, Zero, Zero, One)
                        }

                        M460 ("Jacky- GC32L _EJ0 exit \n", Zero, Zero, Zero, Zero, Zero, One)
                    }
                }
WagesOf â€” Ieri alle 16:00
Do we have to patch that into asus_wmi or something?
Ruineka â€” Ieri alle 16:00
I bet if someone has an XG mobile and has it enabled when booting into linux their keyboard won't disappear.
I think the fix for XG mobile on Windows broke the keyboard for us.
WagesOf â€” Ieri alle 16:01
I ain't spending $2k on a gpu that can be outperformed by a $300 desktop card to test it tho. ðŸ˜…
Ruineka â€” Ieri alle 16:02
Yea no need. I might take the easy way out and make changes to the SSDT to test.
Hmm..thinking about it more DGPS is probably Dedicated Graphics Power State and GPST is Graphics Power State.
jlobue10 â€” Ieri alle 16:07
That would make more sense
Ruineka â€” Ieri alle 16:08
At least it led me down the path to sleep/wake stuff. I really want to know if XG mobile changes our sleep behaviors though.
jlobue10 â€” Ieri alle 16:08
How can we tell if this init is happening properly?
https://github.com/torvalds/linux/blob/0e945134b680040b8613e962f586d91b6d40292d/drivers/platform/x86/asus-wmi.c#L4128
GitHub
linux/drivers/platform/x86/asus-wmi.c at 0e945134b680040b8613e962f5...
Linux kernel source tree. Contribute to torvalds/linux development by creating an account on GitHub.
linux/drivers/platform/x86/asus-wmi.c at 0e945134b680040b8613e962f5...
NeroReflex â€” Ieri alle 16:10
by first defining "properly"
jlobue10 â€” Ieri alle 16:11
I mean sure... let's not be pedantic
Clearly some acpi functions aren't working as we'd want 
Seems that way for Windows too though for sleep 
Ruineka â€” Ieri alle 16:12
Maybe this will help? https://www.kernel.org/doc/html/next/core-api/printk-basics.html
jlobue10 â€” Ieri alle 16:12
Basic functionality being broken with devices disappearing and not coming back
It will definitely be interesting to see the dump with the new BIOS coming October 12th
I wonder if the audio properties will be in there
Ruineka â€” Ieri alle 16:16
In SSDT8
                          If ((\_SB.ATKD.MMFG == One))
                            {
                                \_SB.ATKD.MMFG = Zero
                            }
NeroReflex â€” Ieri alle 16:20
......... that does not look like something one should do.....
svindled â€” Ieri alle 16:22
haha so acpi is basically like "if keyboard on, turn it off" 
Ruineka â€” Ieri alle 16:25
Thats all under NPCF (Nvidia Platform Controller Framework?)
svindled â€” Ieri alle 16:26
in an amd device, nvidia still finds a way to fuck us, if that's what NPCF stands for 
Ruineka â€” Ieri alle 16:26
Probably related to the Nvidia XG mobile or it's universal code they just toss in on all laptops/handhelds
svindled â€” Ieri alle 16:27
that makes sense
Ruineka â€” Ieri alle 16:27
SSDT8 seems to be directly related to GPU/XG mobile stuff though and the sleep slates for it.
jlobue10 â€” Ieri alle 16:32
How nice would it be if the October 12th BIOS update just fixes sleep for us with no extra effort? Lmao
Ruineka â€” Ieri alle 16:32
lol
RHUB = Root Hub?
 Scope (\_SB.PCI0.GP19.XHC3.RHUB.PRT2)

XHCI Root Hub Port 2?
ruineka@ruineka-devonenotebookpc acpidump]$ grep -i "RHUB" *.dsl
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT2._PLD.XPLD */
Mostra
RHUB.txt
5 KB
Yea definitely USB. What port was the controller connected to anyone remember?
Ruineka â€” Ieri alle 16:43
SSDT15 has a lot of USB stuff and SSDT24 has SMBUS.
NeroReflex â€” Ieri alle 16:47
Lsusb output?
Ruineka â€” Ieri alle 16:47
I'm not at my device atm. I see power stuff for the USB/PCI hubs in SSDT15.
jlobue10 â€” Ieri alle 16:48
Yeah lsusb -v
0b05:1abe NKey device, iirc 
I forget and am away from device too
NeroReflex â€” Ieri alle 16:49
Going to mine
Hold on
Bus 008 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 007 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 006 Device 004: ID 0781:5590 SanDisk Corp. Ultra Dual
Bus 006 Device 003: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 006 Device 002: ID 1d5c:5001 Fresco Logic USB3.0 Hub
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 004: ID 046d:c52b Logitech, Inc. Unifying Receiver
Bus 005 Device 005: ID 1b3f:2008 Generalplus Technology Inc. USB Audio Device
Bus 005 Device 003: ID 14cd:8601 Super Top 4-Port hub
Bus 005 Device 002: ID 1d5c:5011 Fresco Logic USB2.0 Hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 005: ID 1c7a:0588 LighTuning Technology Inc. ETU905A86-E
Bus 001 Device 004: ID 0489:e0f5 Foxconn / Hon Hai Wireless_Device
Bus 001 Device 003: ID 0b05:1abe ASUSTek Computer, Inc. N-KEY Device
Bus 001 Device 002: ID 045e:028e Microsoft Corp. Xbox360 Controller
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Ruineka â€” Ieri alle 16:51
Device wake notify list
Scope (\_GPE)
    {
        Method (_L1A, 0, NotSerialized)  // _Lxx: Level-Triggered GPE, xx=0x00-0xFF
        {
            M460 ("  OEM-ASL-\\_GPE._L1A\n", Zero, Zero, Zero, Zero, Zero, Zero)
            If (CondRefOf (\_SB.PCI0.GP19))
Mostra
USB_Notify_Wake.txt
3 KB
NeroReflex â€” Ieri alle 16:51
Bus 001 Device 003: ID 0b05:1abe ASUSTek Computer, Inc. N-KEY Device
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
Mostra
message.txt
9 KB
Ruineka â€” Ieri alle 16:58
Thanks
Object M460 does ALOT
dsdt.dsl:    External (_SB_.M460, MethodObj)    // 7 Arguments
dsdt.dsl:    External (_SB_.PCI0.GP17.VGA_.M460, MethodObj)    // 7 Arguments
dsdt.dsl:                        M460 ("PLA-ASL-\\_SB.PCI0.GP17.VGA._DOD\n", Zero, Zero, Zero, Zero, Zero, Zero)
dsdt.dsl:                            M460 ("PLA-ASL-\\_SB.PCI0.GP17.VGA.LCD._BCL\n", Zero, Zero, Zero, Zero, Zero, Zero)
dsdt.dsl:                                M460 ("PLA-ASL-\\_SB.PCI0.GP17.VGA.LCD._BCM Arg0 = 0x%X\n", ToInteger (Arg0), Zero, Zero, Zero, Zero, Zero)
dsdt.dsl:            M460 ("PLA-ASL-_SB.PCI0.GPPX.PXCR\n", Zero, Zero, Zero, Zero, Zero, Zero)... (42 KB rimanenti)
Mostra
ACPI_OBJECT_M460.txt
92 KB
Ruineka â€” Ieri alle 17:52
If you blacklist ehci-hcd and boot Linux the N-Key will be missing when you manually enable it with modprobe after.
NeroReflex â€” Ieri alle 18:40
That's correct.... It is the hub n-key is virtually (or phisically?) attached to, right?
Ruineka â€” Ieri alle 19:02
cat /proc/acpi/wakeup 
Device    S-state      Status   Sysfs node
GPP0      S4    *enabled   pci:0000:00:01.1
SWUS      S4    *disabled
SWDS      S4    *disabled
GP11      S4    *disabled
SWUS      S4    *disabled
GP12      S4    *disabled
SWUS      S4    *disabled
XHC0      S4    *enabled   pci:0000:0a:00.3
XHC1      S4    *enabled   pci:0000:0a:00.4
XHC2      S4    *disabled  pci:0000:0c:00.0
XHC3      S4    *enabled   pci:0000:0c:00.3
XHC4      S4    *enabled   pci:0000:0c:00.4
NHI0      S4    *disabled
NHI1      S4    *disabled
NeroReflex â€” Ieri alle 19:24
I'm not following
Ruineka â€” Ieri alle 19:53
Sorry, was just taking some notes.
NeroReflex â€” Ieri alle 19:54
Well in ACPI I am nearly a zero.... I work with arm devices so I have to deal with those kind of device trees
Ruineka â€” Ieri alle 19:55
I'll start putting findings/notes here. https://github.com/ruineka/rog-ally-re/blob/main/acpi-notes.txt
GitHub
rog-ally-re/acpi-notes.txt at main Â· ruineka/rog-ally-re
Contribute to ruineka/rog-ally-re development by creating an account on GitHub.
rog-ally-re/acpi-notes.txt at main Â· ruineka/rog-ally-re
NeroReflex â€” Ieri alle 20:03
Tell me when you update that pls
Beside.... It is possible to overwrite acpi methods, right?
Ruineka â€” Ieri alle 20:12
Yea, it's common to do this for hackintosh systems.
pastaq â€” Ieri alle 20:14
You can follow the repo
NeroReflex â€” Ieri alle 20:15
Yeah.... Right..... Wtf is wrong with me today?
NeroReflex â€” Ieri alle 20:16
I remember watching a friend of mine doing that ðŸ˜® a long time ago.....
tomoniutaou33 â€” Ieri alle 21:01
Calibrating the joystick on Windows will also be reflected on Linux.  When it was C, the LED was also inherited, but the LED is no longer inherited.
Ruineka â€” Ieri alle 21:15
I kept thinking this was webcam but it looks more like "Writable Embedded Controller" 
PCI0.SBRG.EC0.WEBC
WagesOf â€” Ieri alle 21:16
There are strings for an intersil microcontroller in the mcu bios flashes.
Ruineka â€” Ieri alle 21:17
Here is a grep
dsdt.dsl:            ^PCI0.SBRG.EC0.WEBC (0x30, One, TMBF)
dsdt.dsl:                        Return (^^PCI0.SBRG.EC0.WEBC (0x28, One, PLTW))
dsdt.dsl:                        Return (^^PCI0.SBRG.EC0.WEBC (0x29, One, PLON))
dsdt.dsl:                        Return (^^PCI0.SBRG.EC0.WEBC (0x39, One, PLAO))
dsdt.dsl:                        Return (^^PCI0.SBRG.EC0.WEBC (0x38, One, PLPS))
dsdt.dsl:                        Return (^^PCI0.SBRG.EC0.WEBC (0x2D, One, PLFW))
Mostra
EC_Writes.txt
3 KB
Ruineka â€” Ieri alle 21:18
Would make sense. I see calibration stuff in the ACPI.
It's easier to read this now that I have deciphered a lot of it. Especially when looking at the Device Status and Device Policy bits.
Here is an example of the WMI events making reference to a EC write.
                    If ((IIA0 == 0x001200C2))
                    {
                        Name (SGTT, Buffer (One)
                        {
                             0x00                                             // .
                        })
                        SGTT [Zero] = IIA1 /* \_SB_.ATKD.WMNB.IIA1 */
                        ^^PCI0.SBRG.EC0.WEBC (0x2E, One, SGTT)
                        Return (One)
                    }
tomoniutaou33 â€” Ieri alle 21:23
L.T.  RT also works fine.  However, I can no longer go back to C.
Ruineka â€” Ieri alle 21:26
This writes the fan curve to the EC.
                    If ((IIA0 == 0x00110024))
                    {
                        Return (^^PCI0.SBRG.EC0.SUFC (IIA1, IIA2, IIA3, IIA4, 0x40))
                    }
        Method (SUFC, 5, NotSerialized)
        {
            Name (DUBF, Buffer (0x10)
            {
                /* 0000 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ........
                /* 0008 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   // ........
            })
            Name (UFC0, Buffer (One)
            {
                 0x00                                             // .
            })
            DUBF [Zero] = (Arg0 >> Zero)
            DUBF [One] = (Arg0 >> 0x08)
            DUBF [0x02] = (Arg0 >> 0x10)
            DUBF [0x03] = (Arg0 >> 0x18)
            DUBF [0x04] = (Arg1 >> Zero)
            DUBF [0x05] = (Arg1 >> 0x08)
            DUBF [0x06] = (Arg1 >> 0x10)
            DUBF [0x07] = (Arg1 >> 0x18)
            DUBF [0x08] = (Arg2 >> Zero)
            DUBF [0x09] = (Arg2 >> 0x08)
            DUBF [0x0A] = (Arg2 >> 0x10)
            DUBF [0x0B] = (Arg2 >> 0x18)
            DUBF [0x0C] = (Arg3 >> Zero)
            DUBF [0x0D] = (Arg3 >> 0x08)
            DUBF [0x0E] = (Arg3 >> 0x10)
            DUBF [0x0F] = (Arg3 >> 0x18)
            UFC0 [Zero] = Arg4
            WEBC (0x20, One, UFC0)
            Return (WEBC (0x22, 0x10, DUBF))
        }
jlobue10 â€” Ieri alle 21:28
So if you left LEDs enabled in Windows, that doesn't carry over to Linux any more after the latest MCU update?
adolfotregosa â€” Ieri alle 21:30
it does. I have mine working
pastaq â€” Ieri alle 21:31
He's asking about the latest MCU update. Did you install the new version since testing?
adolfotregosa â€” Ieri alle 21:31
I didn't understand.. I have 313, leds are working.
jlobue10 â€” Ieri alle 21:35
Sweet, thanks for confirming
Maybe I misunderstood the comment
adolfotregosa â€” Ieri alle 21:36
i did not get it either but led are working fine
tomoniutaou33 â€” Ieri alle 21:36
yes.
It lights up at startup and disappears before the chimera appears.  In the Windows settings, it is turned on when driving, but now it disappears.  When I was using C, it was working with the same settings.
jlobue10 â€” Ieri alle 21:36
Was going to make me speed up my investigation of sending that enable packet, if it was broken. ðŸ˜‚ 
jlobue10 â€” Ieri alle 21:36
Are you on a kernel with N-Key keyboard backlight quirk? 
You need to turn keyboard brightness up from zero Linux side if so 
adolfotregosa â€” Ieri alle 21:38
tomoniutaou33 â€” Ieri alle 21:38
Which kernel will it be?  I'm currently using 6.6.0.
jlobue10 â€” Ieri alle 21:39
I would assume yes if they go dark
adolfotregosa â€” Ieri alle 21:39
leds stay with my settings
jlobue10 â€” Ieri alle 21:39
That's how it is before turning keyboard brightness up
adolfotregosa â€” Ieri alle 21:39
openrgb really needs brightness implemented
jlobue10 â€” Ieri alle 21:40
It's why the OpenRGB dev thought LED control was lost, but in fact it's there with brightness zero ðŸ˜‚ 
Really kinda a comical situation there
adolfotregosa â€” Ieri alle 21:40
for sure
jlobue10 â€” Ieri alle 21:41
The new calibration stuff should be really nice when I get around to putting the hall effect sticks in
adolfotregosa â€” Ieri alle 21:41
I put them in, lasted 2 min
jlobue10 â€” Ieri alle 21:41
I have them in hand, just haven't found the time for the swap
You took them back out?
WagesOf â€” Ieri alle 21:42
I needed it, even the right stick was off center and needed a recalibration
adolfotregosa â€” Ieri alle 21:42
granted It was with 312
WagesOf â€” Ieri alle 21:42
313s calibration put the center in the middle for me. ðŸ¤£
jlobue10 â€” Ieri alle 21:42
They just feel so much better on Steam Deck to me. I need the Hall effect sticks 
I know there is the interference issue with the left stick, but the kit that I bought came with steps to mitigate and/ or solve that 
adolfotregosa â€” Ieri alle 21:44
both my sticks did not center and one of them did not go completely to the right. The cherry on top of cake was the trigger intreference. The anti shield paper did not fix it
honestly, the stocks ones are fine
WagesOf â€” Ieri alle 21:44
I still needed to do an actual calibration since the center point was off and the windows and Linux calibrations don't calibrate to the mcu
jlobue10 â€” Ieri alle 21:44
Damn, yeah I'd take them back out if it was janky like that
WagesOf â€” Ieri alle 21:45
I don't plan to replace the left stick. My right one was actually broken so I got a replacement hall.
jlobue10 â€” Ieri alle 21:45
But cal saves to MCU now, or no?
adolfotregosa â€” Ieri alle 21:45
Probably with mcu 313 after calibration they maybe work correctly but the interference wont be fixed 
adolfotregosa â€” Ieri alle 21:45
i think yes
WagesOf â€” Ieri alle 21:45
Seems to, it carries the calibration between. OS'
jlobue10 â€” Ieri alle 21:45
Interference is a hardware problem of magnets in close proximity
And nice
Best you can do is mitigate
WagesOf â€” Ieri alle 21:45
You have to calibrate in ac tho
jlobue10 â€” Ieri alle 21:46
Yeah, ok. Thanks for the info
adolfotregosa â€” Ieri alle 21:47
in my opinion don't change them . The ones you received from handydiy or whatever are not 100% compatible. They seam but they are not. If you still go for it, becareful when tighting the joysticks because you will bend them.
jlobue10 â€” Ieri alle 21:47
Good to know
adolfotregosa â€” Ieri alle 21:48
the screws will push one of the tabs down because it is not flush with the pcb
Ruineka â€” Ieri alle 21:48
Found the EC writes to enable/disable the GPU. I just need to find the EC writes for the keyboard...WEBC is Write EC and REBC is Read EC.
WagesOf â€” Ieri alle 21:48
I agree. Potentiometer sticks are fine and easy to replace in three years when they wear out.
But for $20 it was worth a test. ðŸ˜Ž
adolfotregosa â€” Ieri alle 21:48
my thinking , sure, prefer stocks
jlobue10 â€” Ieri alle 21:49
ALLY default sticks are pretty good, and maybe the interference with hall effect triggers is not worth the hassle. Lmao
adolfotregosa â€” Ieri alle 21:49
in 3 years we will be talking about ally 2 or 3 lol
WagesOf â€” Ieri alle 21:49
Totally makes sense why they designed it to not use hall effect sticks tho. Just not enough room.
adolfotregosa â€” Ieri alle 21:50
save yourself the trouble.
WagesOf â€” Ieri alle 21:50
For me, best mod so far is the port cover I got from Etsy. ðŸ¤£
NeroReflex â€” Ieri alle 21:50
At that point my ally would have already been sold, m2 macs will hava asahi working perfectly and I will have one of those lol
NeroReflex â€” Ieri alle 21:50
Not led disconnection?
jlobue10 â€” Ieri alle 21:51
90 degree NVMe mod was clutch so that I can stare at a bunch of installed games that I don't have time to play. :KEKW: 
WagesOf â€” Ieri alle 21:51
Nope, but that's the one I suggest most often. ðŸ˜‰
adolfotregosa â€” Ieri alle 21:51
for me it was the grips. I designed a new stand. but I also did the port cover lol
NeroReflex â€” Ieri alle 21:51
I have yet to print those ahahah
WagesOf â€” Ieri alle 21:52
I can't believe asus just leaves that wide port with so many bare contacts just hanging in the breeze.
jlobue10 â€” Ieri alle 21:52
The XG Mobile port?
WagesOf â€” Ieri alle 21:52
Yep
jlobue10 â€” Ieri alle 21:52
I need a cover for that
NeroReflex â€” Ieri alle 21:52
That fucking port is the source of all issues!!!!
jlobue10 â€” Ieri alle 21:52
So annoying playing around to find USB-C ðŸ˜‚
WagesOf â€” Ieri alle 21:53
I'd 1000% prefer a standard usb4 port, but you can't make a proprietary egpu with a 400% markup with that.
jlobue10 â€” Ieri alle 21:53
Now you're thinking like Asus marketing
Ruineka â€” Ieri alle 21:56
@jlobue10 I haven't found any direct EC or WMI calls for anything related to the keyboard, but this is suppose to get stored into memory. https://github.com/ruineka/rog-ally-re/blob/484a6212dee09adc078f66182648cb63ac5e5bcf/acpi-notes.txt#L89
GitHub
rog-ally-re/acpi-notes.txt at 484a6212dee09adc078f66182648cb63ac5e5...
Contribute to ruineka/rog-ally-re development by creating an account on GitHub.
rog-ally-re/acpi-notes.txt at 484a6212dee09adc078f66182648cb63ac5e5...
This is not included here. https://github.com/torvalds/linux/blob/master/include/linux/platform_data/x86/asus-wmi.h
GitHub
linux/include/linux/platform_data/x86/asus-wmi.h at master Â· torval...
Linux kernel source tree. Contribute to torvalds/linux development by creating an account on GitHub.
linux/include/linux/platform_data/x86/asus-wmi.h at master Â· torval...
ï»¿
ruineka@ruineka-devonenotebookpc acpidump]$ grep -i "RHUB" *.dsl
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT2._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT3._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT3._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT4._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT4._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT5._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT5._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT6._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT6._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT7._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC0.RHUB.PRT7._PLD.XPLD */
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC1.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC1.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP17.XHC1.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP17.XHC1.RHUB.PRT2._PLD.XPLD */
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC2.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC2.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC2.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC2.RHUB.PRT2._PLD.XPLD */
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC3.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC3.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC3.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC3.RHUB.PRT2._PLD.XPLD */
dsdt.dsl:        Device (RHUB)
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC4.RHUB.PRT1._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC4.RHUB.PRT1._PLD.XPLD */
dsdt.dsl:                    Return (XUPC) /* \_SB_.PCI0.GP19.XHC4.RHUB.PRT2._UPC.XUPC */
dsdt.dsl:                    Return (XPLD) /* \_SB_.PCI0.GP19.XHC4.RHUB.PRT2._PLD.XPLD */
dsdt.dsl:    Scope (_SB.PCI0.GP17.XHC0.RHUB.PRT4)
ssdt15.dsl:    External (_SB_.PCI0.GP19.XHC3.RHUB.PRT2, DeviceObj)
ssdt15.dsl:    External (_SB_.PCI0.GP19.XHC4.RHUB.PRT2, DeviceObj)
ssdt15.dsl:    Scope (\_SB.PCI0.GP19.XHC3.RHUB.PRT2)
ssdt15.dsl:            If ((((\DDEP == One) && CondRefOf (\_SB.PCI0.GP19.XHC3.RHUB.PRT2._DSD)) && (CondRefOf (\_SB.PCI0.GP19.NHI0
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC3.RHUB.PRT2._DEP  Return Package (1) {\\_SB.PCI0.GP19.NHI0}\n", Zero, Zero, Zero, Zero, Zero, Zero)
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC3.RHUB.PRT2._DEP  Return Package (1) {\\_SB.PCI0}\n", Zero, Zero, Zero, Zero, Zero, Zero)
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC3.RHUB.PRT2._DSM (UUID 0x%X, 0x%X, 0x%X)\n", UID0, Arg1, Arg2, Zero, Zero, Zero)
ssdt15.dsl:    Scope (\_SB.PCI0.GP19.XHC4.RHUB.PRT2)
ssdt15.dsl:            If ((((\DDEP == One) && CondRefOf (\_SB.PCI0.GP19.XHC4.RHUB.PRT2._DSD)) && (CondRefOf (\_SB.PCI0.GP19.NHI1
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC4.RHUB.PRT2._DEP  Return Package (1) {\\_SB.PCI0.GP19.NHI1}\n", Zero, Zero, Zero, Zero, Zero, Zero)
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC4.RHUB.PRT2._DEP  Return Package (1) {\\_SB.PCI0}\n", Zero, Zero, Zero, Zero, Zero, Zero)
ssdt15.dsl:                M460 ("  OEM-ASL-\\_SB.PCI0.GP19.XHC4.RHUB.PRT2._DSM (UUID 0x%X, 0x%X, 0x%X)\n", UID0, Arg1, Arg2, Zero, Zero, Zero)
```

Yea definitely USB. What port was the controller connected to anyone remember?

Going to mine
Hold on
```
Bus 008 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 007 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 006 Device 004: ID 0781:5590 SanDisk Corp. Ultra Dual
Bus 006 Device 003: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 006 Device 002: ID 1d5c:5001 Fresco Logic USB3.0 Hub
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 004: ID 046d:c52b Logitech, Inc. Unifying Receiver
Bus 005 Device 005: ID 1b3f:2008 Generalplus Technology Inc. USB Audio Device
Bus 005 Device 003: ID 14cd:8601 Super Top 4-Port hub
Bus 005 Device 002: ID 1d5c:5011 Fresco Logic USB2.0 Hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 005: ID 1c7a:0588 LighTuning Technology Inc. ETU905A86-E
Bus 001 Device 004: ID 0489:e0f5 Foxconn / Hon Hai Wireless_Device
Bus 001 Device 003: ID 0b05:1abe ASUSTek Computer, Inc. N-KEY Device
Bus 001 Device 002: ID 045e:028e Microsoft Corp. Xbox360 Controller
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

Device wake notify list:

```
Scope (\_GPE)
    {
        Method (_L1A, 0, NotSerialized)  // _Lxx: Level-Triggered GPE, xx=0x00-0xFF
        {
            M460 ("  OEM-ASL-\\_GPE._L1A\n", Zero, Zero, Zero, Zero, Zero, Zero)
            If (CondRefOf (\_SB.PCI0.GP19))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP19.NHI0))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19.NHI0, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19.NHI0, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP19.NHI1))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19.NHI1, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19.NHI1, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP19.XHC2))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19.XHC2, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19.XHC2, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP19.XHC3))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19.XHC3, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19.XHC3, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP19.XHC4))
            {
                M460 ("    Notify (\\_SB.PCI0.GP19.XHC4, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP19.XHC4, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP11))
            {
                M460 ("    Notify (\\_SB.PCI0.GP11, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP11, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP11.SWUS))
            {
                M460 ("    Notify (\\_SB.PCI0.GP11.SWUS, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP11.SWUS, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP12))
            {
                M460 ("    Notify (\\_SB.PCI0.GP12, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP12, 0x02) // Device Wake
            }

            If (CondRefOf (\_SB.PCI0.GP12.SWUS))
            {
                M460 ("    Notify (\\_SB.PCI0.GP12.SWUS, 0x2)\n", Zero, Zero, Zero, Zero, Zero, Zero)
                Notify (\_SB.PCI0.GP12.SWUS, 0x02) // Device Wake
            }
        }
    }
```

If you blacklist ehci-hcd and boot Linux the N-Key will be missing when you manually enable it with modprobe after.

Personal note:
```
cat /proc/acpi/wakeup 
Device    S-state      Status   Sysfs node
GPP0      S4    *enabled   pci:0000:00:01.1
SWUS      S4    *disabled
SWDS      S4    *disabled
GP11      S4    *disabled
SWUS      S4    *disabled
GP12      S4    *disabled
SWUS      S4    *disabled
XHC0      S4    *enabled   pci:0000:0a:00.3
XHC1      S4    *enabled   pci:0000:0a:00.4
XHC2      S4    *disabled  pci:0000:0c:00.0
XHC3      S4    *enabled   pci:0000:0c:00.3
XHC4      S4    *enabled   pci:0000:0c:00.4
NHI0      S4    *disabled
NHI1      S4    *disabled
```

Q: Calibrating the joystick on Windows will also be reflected on Linux.  When it was C, the LED was also inherited, but the LED is no longer inherited.

A: Would make sense. I see calibration stuff in the ACPI.
It's easier to read this now that I have deciphered a lot of it. Especially when looking at the Device Status and Device Policy bits.
Here is an example of the WMI events making reference to a EC write.

```
                    If ((IIA0 == 0x001200C2))
                    {
                        Name (SGTT, Buffer (One)
                        {
                             0x00                                             // .
                        })
                        SGTT [Zero] = IIA1 /* \_SB_.ATKD.WMNB.IIA1 */
                        ^^PCI0.SBRG.EC0.WEBC (0x2E, One, SGTT)
                        Return (One)
                    }
```

This writes the fan curve to the EC.
```
                    If ((IIA0 == 0x00110024))
                    {
                        Return (^^PCI0.SBRG.EC0.SUFC (IIA1, IIA2, IIA3, IIA4, 0x40))
                    }
```

```
        Method (SUFC, 5, NotSerialized)
        {
            Name (DUBF, Buffer (0x10)
            {
                /* 0000 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ........
                /* 0008 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   // ........
            })
            Name (UFC0, Buffer (One)
            {
                 0x00                                             // .
            })
            DUBF [Zero] = (Arg0 >> Zero)
            DUBF [One] = (Arg0 >> 0x08)
            DUBF [0x02] = (Arg0 >> 0x10)
            DUBF [0x03] = (Arg0 >> 0x18)
            DUBF [0x04] = (Arg1 >> Zero)
            DUBF [0x05] = (Arg1 >> 0x08)
            DUBF [0x06] = (Arg1 >> 0x10)
            DUBF [0x07] = (Arg1 >> 0x18)
            DUBF [0x08] = (Arg2 >> Zero)
            DUBF [0x09] = (Arg2 >> 0x08)
            DUBF [0x0A] = (Arg2 >> 0x10)
            DUBF [0x0B] = (Arg2 >> 0x18)
            DUBF [0x0C] = (Arg3 >> Zero)
            DUBF [0x0D] = (Arg3 >> 0x08)
            DUBF [0x0E] = (Arg3 >> 0x10)
            DUBF [0x0F] = (Arg3 >> 0x18)
            UFC0 [Zero] = Arg4
            WEBC (0x20, One, UFC0)
            Return (WEBC (0x22, 0x10, DUBF))
        }
```

Found the EC writes to enable/disable the GPU. I just need to find the EC writes for the keyboard...WEBC is Write EC and REBC is Read EC.

When that is called this gets set.
```
SMIF = 0x04
SMCM = 0xA3
```

This seems to be tied to the same memory as the sleep
```
        OperationRegion (GPSC, SystemIO, 0xB2, 0x02)
        Field (GPSC, ByteAcc, NoLock, Preserve)
        {
            SMCM,   8, 
            SMST,   8
        }
```

The following disables armory crate in BIOS (I think):

```
        OperationRegion (ARSO, SystemMemory, ARSB, 0x05)
        Field (ARSO, AnyAcc, NoLock, Preserve)
        {
            ARSS,   32, 
            ARSE,   8
        }
    }
```

```
        Device (ARLS)
        {
            Name (_HID, "ASUS9001")  // _HID: Hardware ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (ARSE)
                {
                    Return (0x0F)
                }
                Else
                {
                    Return (Zero)
                }
            }
        }
    }
```

__HE GOT THE POINT__ Arse, lol

need a way to figure out the IIA0 ID's.
```
                    If ((IIA0 == 0x00090019))
                    {
                        EGIF = ^^PCI0.SBRG.EC0.REBC (0x1C, 0x04)
                        Local1 = DerefOf (EGIF [Zero])
                        If ((Local1 & 0x40))
                        {
                            Return (0x00010001)
                        }
                        ElseIf ((Local1 & 0x80))
                        {
                            Return (0x00010000)
                        }
                        Else
                        {
                            Return (Zero)
                        }
                    }
```

This is a device status check that changes behavior depending on what is read from the EC.

EGIF = EC address 0x1c, 0x04
Local1 is set to this dereferenced value. If value is True and 0x40 do this, if it's true and 0x80 do that. Otherwise return zero.
Sure would be nice if 0x00090019 was in english saying "Hey, this is like totally the keyboard device!"


__svindled__: https://lore.kernel.org/lkml/20210704222148.880848-4-luke@ljones.dev/ I think it might be related to XG mobile? this patch for asus-wmi has the define in the header as ASUS_WMI_DEVID_EGPU

Wow thats the egpu
He did exactly what I found here. LOL
The snippet I posted above is 0x00090019 which apparently is the egpu states.
That confirms to me that this should be keyboard then.
0x00100021
IANE seems to notify the system of the "keys" pressed.
looks like this confirms it as well. https://github.com/seerge/g-helper/issues/605
```
Invoke-CimMethod (Get-CimInstance -Namespace root/wmi -ClassName AsusAtkWmi_WMNB) -MethodName DEVS -Arguments @{Device_ID=0x00100021; Control_status=0x20}
```

```
                    If ((IIA0 == 0x00100022))
                    {
                        If ((IIA1 & 0x02))
                        {
                            ^^PCI0.SBRG.EC0.STB1 (0x04)
                            ^^PCI0.SBRG.EC0.STB1 (0x05)
                            FNIV = One
                            Return (One)
                        }
                        Else
                        {
                            ^^PCI0.SBRG.EC0.KINI ()
                            Return (One)
                        }

                        Return (Zero)
                    }
```

KINI= Keyboard Initalize?
```
        Method (KINI, 0, Serialized)
        {
            STB1 (0x02)
            STB1 (0x04)
            FNIV = Zero
        }
```
That happens right before the keyboard key checks it seems..

We can read and write to ram
```
PCI0.SBRG.EC0.RRAM
PCI0.SBRG.EC0.WRAM
```

Lol..could it really be..
Could it be because LID is not implemented in the ACPI so the keyboard isn't handled properly on suspend/wake?
Looking at a laptop for reference and there is this.
```
                    ^^^^^ATKD.IANE (0xE9) // 233, on lid open/close
```

I'm able to send key events even when the N key isn't visble. This is progress.
As an example
```
echo '\\_SB.ATKD.IANE' 0xBC > /proc/acpi/call
```

Looks like 0xE5 is suppose to be linked to the RGB lights when charging in sleep mode.

It's interesting that SB.ATKD.IANE directly speaks to the WMI driver on Linux.

__Q__: Maybe the purple flashing lights enabled when charger plugged in (during sleep)?
__A__: Yea that seems to be the case. There is a section for LEDS but it is blank in the ACPI

Makes sense why it's WMI signals. This is all under the WMI stuff

```
            Method (IANE, 1, Serialized)
            {
                IANQ (Arg0)
                Notify (ATKD, 0xFF) // Hardware-Specific
            }

            Method (INIT, 1, NotSerialized)
            {
                ATKP = One
                Return (One)
            }
```

The ACPI has stuff for backlight controls.
```
            If ((BLCT == Zero))
            {
                If (ATKP)
                {
                    ^^^^ATKD.IANE (0x33)
                }
            }
            ElseIf ((BLCT == One))
            {
                If (ATKP)
                {
                    ^^^^ATKD.IANE (0x35)
                }
            }
        }
```

So if you send 0x33/0x35 you can do different events.

__svindled__ I have a script that's supposed to run through 0-255 for \_SB.ATKD.IANE and one of them kills network lol
i'm assuming it's the hardware/software switch for disabling the wifi card
__svindled__ lol 0x5d puts system into airplane mode and 0x88 takes it out


What is going on?
and I was doing some sleep thinking. Those events that triggered the airplane mode must have been the keyboard button to do just that.

We need to set the keyboard to the presence bit because for whatever reason it's lost on sleep. It must be switch to the UNKNOWN BIT when sleeping or perhaps disabled.

I think the dedicated GPU was having issues with the device states as well and it needed to be handled because when the PCI lost power the state was lost.
The firmware hides the dGPU in the same way the keyboard is being hidden from the OS I betcha.
@pastaq Or we can just use WMI calls to handle inputs and to hell with the rest

[DO] Something like this
```
echo '\\_SB.ATKD.IANE' 0xBC > /proc/acpi/call
```

__NeroReflex__
```
[ 3343.301950] asus_wmi: asus-wmi.c asus_wmi_notify: 188 -- calling asus_wmi_handle_event_code
[ 3343.301985] asus_wmi: Unknown key code 0xbc
[ 3343.302024] asus_wmi: asus-wmi.c asus_wmi_notify: 65535 -- WMI_EVENT_QUEUE_END | WMI_EVENT_MASK
```

yes, my debug print do work
and.... issuing that command made the screen exiting its low luminosity state

probably a screen brightness button
I put together a list of unknown devices with on/off bits.

```
0x0012007E
0x00060026
0x00130022
0x00100051
```

I guess we do DSDT override to turn them all off and see if the keyboard disappears? LOL
I suspect it might be this because I don't think it's intended behavior to DISABLE the keyboard...
```
                    If ((IIA0 == 0x00100051))
                    {
                        Return (0x00010001)
                    }
```
I think it's just supposed to be connected at all times.
I guess I should be able to do this with a call though.

```
[ WMI Device With on/off UNKNOWN]

0x0012007E (RMSA)
0x00060026 (PCI0.SBRG.EC0.STA8) (If value is 0x04 then enable)
0x00130022 (APSC)
0x00100051 (No Reference)
```

STA8 seems to send a cmd to EDA1 which is directly related to the EC.
Yea it checks if EDA1 is == to 0x04 and if so then enable.

__Q__: enable the EC you mean?
__A__: The device, whatever it is.

Ah when RMSA is used it sends a IANE
```
        Method (_QF2, 0, NotSerialized)  // _Qxx: EC Query, xx=0x00-0xFF
        {
            If ((RMSA == One))
            {
                ^^^^ATKD.IANE (0x68)
            }
        }
```

So 0x0012007E (RMSA) sets an enable status and when it's value is "ONE" then ATKD.IANE 0x68 is sent.

There are some EC writes.

```
If ((IIA0 == 0x0012007E))
                    {
                        Name (DUCF, Buffer (0x05)
                        {
                             0x00, 0x00, 0x00, 0x00, 0x00                     // .....
                        })
                        RMSA = (IIA2 & One)
                        DUCF [Zero] = (IIA1 >> Zero)
                        DUCF [One] = (IIA1 >> 0x08)
                        DUCF [0x02] = (IIA1 >> 0x10)
                        DUCF [0x03] = (IIA1 >> 0x18)
                        DUCF [0x04] = (IIA2 >> Zero)
                        ^^PCI0.SBRG.EC0.WEBC (0x3D, 0x05, DUCF)
                        Return (One)
                    }

                    If ((IIA0 == 0x0012007F))
                    {
                        Name (DUDF, Buffer (0x02)
                        {
                             0x00, 0x00                                       // ..
                        })
                        If ((RMSA == One))
                        {
                            DUDF [Zero] = (IIA1 >> Zero)
                            DUDF [One] = (IIA1 >> 0x08)
                            ^^PCI0.SBRG.EC0.WEBC (0x3E, 0x02, DUDF)
                        }

                        Return (One)
                    }
```

Thinking it has to be this 0x0012007E (RMSA). I checked to see if laptops have this device and they don't. This is pretty specific to the ally from what I can tell.

All the other "unknown" suspects were in the laptop DSDT.
Relay Mode Switch Agent? RMSA LOL >.<
RMSA (Mondern Stanby Assist)

If Modern Standby Assist then set enable flag, else set disable flag for 0x0012007E device:
```
                    If ((IIA0 == 0x0012007E))
                    {
                        If ((RMSA == One))
                        {
                            Return (0x00010001)
                        }
                        Else
                        {
                            Return (0x00010000)
                        }
                    }
```

Nice. with a DSDT override forcing return 0x00010001 to 0x0012007e my keyboard is disabled on reboot.
I have to sleep the device once to get the N-Key to show up. This is completely backwards to how it normally is.

__Q__: do you lose it any other sleep?
__A__: Yea unfortunately.

Look at this https://github.com/seerge/g-helper/issues/520

__NeroReflex__: executing that ACPI call a second time resumed my leds on standby

Nice. with a DSDT override forcing return 0x00010001 to 0x0012007e my keyboard is disabled on reboot.
I have to sleep the device once to get the N-Key to show up. This is completely backwards to how it normally is.

__NeroReflex__: do you lose it any other sleep?

Yea unfortunately.
Current State (D?)
 - First boot no N-Key
 - Sleep/wake shows N-Key
 - Sleep/Wake again N-Key disappears
I'll force 0x0001000 instead
Oof. Same thing now. Default for me is no N-Key. Eeek.
Same thing after removing the DSDT as well.
I objectively made my device worse.

Good news is that is definitely related to what we want. The bad news is I got it all backwards and borked my device..Need to fix it now
Ah yes. Doing a 40 second power button hold fixes this state.

__NOTE__ 10 seconds did the trick.

This puts the device to sleep.
```
echo '\_SB.PCI0.SBRG.EC0._Q0A' > /proc/acpi/call
```

__Q__: Does it resume properly (not counting known problems) afterwards?
__A__: No seems to act in the same way as pressing the button

__NeroReflex__:
OK.... But I doubt it's the case because freebsd did not slept when I pressed that button
There is something else in between
Not sure if that matters

There are a lot of EC queries you can send. This is where the sleep was at.
```
    Scope (_SB.PCI0.SBRG.EC0)
    {
        Name (F8FG, Zero)
        Name (BLCT, Zero)
        Name (ACNG, Zero)
        Name (DSTI, One)
        Name (NTPF, Zero)
        Name (NTWF, Zero)
        Method (_Q0A, 0, NotSerialized)  // _Qxx: EC Query, xx=0x00-0xFF
        {
            Notify (SLPB, 0x80) // Status Change
        }
```

There are backlight controls, Mic Mute, EGPU, and way more in there.
This shut the device off
```
        Method (_QDE, 0, NotSerialized)  // _Qxx: EC Query, xx=0x00-0xFF
        {
            Notify (PWRB, 0x80) // Status Change
        }
```

It shows the sleep animation too so it's a sleep button event where the other command put it to sleep directly.
This also puts the device to sleep (presses power button)..why so many ways? idk.
```
        Method (_QDF, 0, NotSerialized)  // _Qxx: EC Query, xx=0x00-0xFF
        {
            Notify (PWRB, 0x80) // Status Change
        }
```

__NeroReflex__ *(idiot)*: So I was indeed right lol gj freebsd

These are all the events that can be called by WMI.
https://www.asus.com/support/FAQ/1038312/

The "airplane" mode worked because it's mapped here. https://github.com/torvalds/linux/blob/9ed22ae6be817d7a3f5c15ca22cbc9d3963b481d/drivers/platform/x86/asus-nb-wmi.c#L551

You can turn up volume, change screen brightness, turn display off etc.
RMSA seems to be this. 

The AC/CC and buttons are HID (The keyboard that disappears) and the other stuff were finding is all WMI, which apparently would be used for extra keys if it had a real keyboard.
I'm really thinking the keyboard event disappearing really is an EC bug...

__Q__: When something was disabled on Windows and there is a sleep cycle it also disappears right?
__A__: I think it disappears regardless. And the driver reinitializes that devices you can see it happening from the video of *censored*. Even IF this really is a bug.... It's a solved thing for them because windows handles that properly

*usual idiot*: Probably....  It depends... But now they have a problem. If they don't take into account the workaround they have already shipped ppl will start having problems in windows too
So the choice will be: leave everything as it is because no one is having trouble or use resources to fix that, possibly causing problems
I am pretty sure what will they choose

I'm not so sure it's even going to a suspended state. I think it might quite literally being "powered off". I've messed with all the wake events in ACPI and nothing brings it back. I was messing around with shutdown ACPI calls and tripped up my N-Key.

That's the way it seems. There are a few different methods the ACPI puts the system to sleep/shutdown. It seems strange there are so many...
You can send EC queues to trigger a power event.
They even have a queue that does a PCI Bus Check for the eGPU.

__OUT OF CONTEXT__:
E and F sends a button press with it
Q0E will send a power signal that triggers the Steam sleep animation.

*tested by the usual idiot*:
```
echo '\_SB.PCI0.SBRG.EC0._Q0F' > /proc/acpi/call
echo '\_SB.PCI0.SBRG.EC0._Q0E' > /proc/acpi/call
```
__AND THEY DID NOT WORK__

